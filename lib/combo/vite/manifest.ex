defmodule Combo.Vite.Manifest do
  @moduledoc """
  Handles the manifest file generated by Vite.
  """

  alias __MODULE__.Chunk

  @type raw :: binary()

  @type name :: String.t()
  @type chunk :: Chunk.t()
  @type t :: %{optional(name()) => chunk()}

  @spec parse(raw) :: t()
  def parse(binary) when is_binary(binary) do
    chunks_map = JSON.decode!(binary)

    Map.new(chunks_map, fn {name, chunk} ->
      chunk = %Chunk{
        src: Map.get(chunk, "src", nil),
        file: Map.fetch!(chunk, "file"),
        css: Map.get(chunk, "css", []),
        assets: Map.get(chunk, "assets", []),
        is_entry?: Map.get(chunk, "isEntry", false),
        name: Map.get(chunk, "name", nil),
        names: Map.get(chunk, "names", []),
        is_dynamic_entry?: Map.get(chunk, "isDynamicEntry", false),
        imports: Map.get(chunk, "imports", []),
        dynamic_imports: Map.get(chunk, "dynamicImports", [])
      }

      {name, chunk}
    end)
  end

  @spec fetch_chunk!(t(), name()) :: chunk()
  def fetch_chunk!(%{} = manifest, name) do
    Map.fetch!(manifest, name)
  end

  @spec fetch_imported_chunks!(t(), name()) :: [chunk()]
  def fetch_imported_chunks!(%{} = manifest, name) do
    chunk = fetch_chunk!(manifest, name)

    imports = chunk.imports
    chunks = []
    chunk_names = MapSet.new()
    stack = []

    # dfc (Deep First Collect) - collect imported chunks in a deep-first way
    dfc(imports, chunks, chunk_names, stack, manifest)
  end

  defp dfc([], chunks, _chunk_names, [], _manifest) do
    Enum.reverse(chunks)
  end

  defp dfc([], chunks, chunk_names, [[name | rest_imports] | stack], manifest) do
    chunk = fetch_chunk!(manifest, name)
    new_chunks = [chunk | chunks]
    new_chunk_names = MapSet.put(chunk_names, name)
    dfc(rest_imports, new_chunks, new_chunk_names, stack, manifest)
  end

  defp dfc([name | rest_imports] = imports, chunks, chunk_names, stack, manifest) do
    if MapSet.member?(chunk_names, name) do
      dfc(rest_imports, chunks, chunk_names, stack, manifest)
    else
      chunk = fetch_chunk!(manifest, name)
      new_stack = [imports | stack]
      dfc(chunk.imports, chunks, chunk_names, new_stack, manifest)
    end
  end
end
